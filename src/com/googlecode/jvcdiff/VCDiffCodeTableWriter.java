package com.googlecode.jvcdiff;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.EnumSet;

/**
 * @author David Ehrmann
 * The method calls after construction *must* conform
 * to the following pattern:
 *    {{Add|Copy|Run}* [AddChecksum] Output}*
 *
 * When Output has been called in this sequence, a complete target window
 * (as defined in RFC 3284 section 4.3) will have been appended to
 * out (unless no calls to Add, Run, or Copy were made, in which
 * case Output will do nothing.)  The output will not be available for use
 * until after each call to Output().
 *
 * NOT threadsafe.
 */
public class VCDiffCodeTableWriter implements CodeTableWriterInterface {

	/**
	 * The maximum value for the mode of a COPY instruction.
	 */
	private static final int max_mode_;

	// A series of instruction opcodes, each of which may be followed
	// by one or two Varint values representing the size parameters
	// of the first and second instruction in the opcode.
	private ByteBuffer instructions_and_sizes_;

	// A series of data arguments (byte values) used for ADD and RUN
	// instructions.  Depending on whether interleaved output is used
	// for streaming or not, the pointer may point to
	// separate_data_for_add_and_run_ or to instructions_and_sizes_.
	private ByteBuffer data_for_add_and_run_;
	private ByteBuffer separate_data_for_add_and_run_;

	// A series of Varint addresses used for COPY instructions.
	// For the SAME mode, a byte value is stored instead of a Varint.
	// Depending on whether interleaved output is used
	// for streaming or not, the pointer may point to
	// separate_addresses_for_copy_ or to instructions_and_sizes_.
	private ByteBuffer addresses_for_copy_;
	private ByteBuffer separate_addresses_for_copy_;

	private VCDiffAddressCache address_cache_;

	private int dictionary_size_;

	// The number of bytes of target data that has been encoded so far.
	// Each time Add(), Copy(), or Run() is called, this will be incremented.
	// The target length is used to compute HERE mode addresses
	// for COPY instructions, and is also written into the header
	// of the delta window when Output() is called.
	//
	private int target_length_;

	private final VCDiffCodeTableData code_table_data_;

	// The instruction map facilitates finding an opcode quickly given an
	// instruction inst, size, and mode.  This is an alternate representation
	// of the same information that is found in code_table_data_.
	// TODO VCDiffInstructionMap
	private final Object instruction_map_;

	// The zero-based index within instructions_and_sizes_ of the byte
	// that contains the last single-instruction opcode generated by
	// EncodeInstruction().  (See that function for exhaustive details.)
	// It is necessary to use an index rather than a pointer for this value
	// because instructions_and_sizes_ may be resized, which would invalidate
	// any pointers into its data buffer.  The value -1 is reserved to mean that
	// either no opcodes have been generated yet, or else the last opcode
	// generated was a double-instruction opcode.
	private int last_opcode_index_;

	// If true, an Adler32 checksum of the target window data will be written as
	// a variable-length integer, just after the size of the addresses section.
	private boolean add_checksum_;

	// The checksum to be written to the current target window,
	// if add_checksum_ is true.
	// This will not be calculated based on the individual calls to Add(), Run(),
	// and Copy(), which would be unnecessarily expensive.  Instead, the code
	// that uses the VCDiffCodeTableWriter object is expected to calculate
	// the checksum all at once and to call AddChecksum() with that value.
	// Must be called sometime before calling Output(), though it can be called
	// either before or after the calls to Add(), Run(), and Copy().
	private long checksum_;

	/**
	 * This constructor uses the default code table.
	 * If interleaved is true, the encoder writes each delta file window
	 * by interleaving instructions and sizes with their corresponding
	 * addresses and data, rather than placing these elements into three
	 * separate sections.  This facilitates providing partially
	 * decoded results when only a portion of a delta file window
	 * is received (e.g. when HTTP over TCP is used as the
	 * transmission protocol.)  The interleaved format is
	 * not consistent with the VCDIFF draft standard.
	 * 
	 * @param interleaved Whether or not to interleave the output data
	 */
	public VCDiffCodeTableWriter(boolean interleaved) {
		// TODO
	}

	/**
	 * 
	 * Uses a non-standard code table and non-standard cache sizes.  The caller
	 * must guarantee that code_table_data remains allocated for the lifetime of
	 * the VCDiffCodeTableWriter object.  Note that this is different from how
	 * VCDiffCodeTableReader::UseCodeTable works.  It is assumed that a given
	 * encoder will use either the default code table or a statically-defined
	 * non-standard code table, whereas the decoder must have the ability to read
	 * an arbitrary non-standard code table from a delta file and discard it once
	 * the file has been decoded.
	 * 
	 * @param interleaved
	 * @param near_cache_size
	 * @param same_cache_size
	 */
	public VCDiffCodeTableWriter(boolean interleaved, short near_cache_size, short same_cache_size, VCDiffCodeTableData code_table_data, short max_mode) {
		address_cache_ = new VCDiffAddressCacheImpl(near_cache_size, same_cache_size);
		dictionary_size_ = 0;
		target_length_ = 0;
		code_table_data_ = code_table_data;
		instruction_map_ = null;
		last_opcode_index_ = -1;
		add_checksum_ = false;
		checksum_ = 0;
		InitSectionPointers(interleaved);
	}

	/**
	 * Initializes the constructed object for use.
	 * This method must be called after a VCDiffCodeTableWriter is constructed
	 * and before any of its other methods can be called.  It will return
	 * false if there was an error initializing the object, or true if it
	 *  was successful.  After the object has been initialized and used,
	 * Init() can be called again to restore the initial state of the object.
	 */
	public void Init(int dictionary_size) {
		dictionary_size_ = dictionary_size;
		if (instruction_map_ == null) {
			if (code_table_data_ == VCDiffCodeTableData.kDefaultCodeTableData) {
				instruction_map_ = VCDiffInstructionMap.GetDefaultInstructionMap();
			} else {
				instruction_map_ = new VCDiffInstructionMap(code_table_data_, max_mode_);
			}
		}

		address_cache_.Init();

		target_length_ = 0;
		last_opcode_index_ = -1;
	}

	/**
	 *  Encode an ADD opcode with the "size" bytes starting at data
	 */
	public void Add(byte[] data, int offset, int length) {
		if (offset + length > data.length || length < offset) {
			throw new IllegalArgumentException();
		}

		EncodeInstruction(VCDiffCodeTableData.VCD_ADD, length - offset);
		data_for_add_and_run_.put(data, offset, length);
		target_length_ += length - offset;
	}

	public void AddChecksum(int checksum) {
		// TODO Auto-generated method stub

	}

	/**
	 *  Encode a COPY opcode with args "offset" (into dictionary) and "size" bytes.
	 */
	public void Copy(int offset, int size) {
		// TODO Auto-generated method stub

	}

	/**
	 * There should not be any need to output more data
	 * since EncodeChunk() encodes a complete target window
	 * and there is no end-of-delta-file marker.
	 */
	public void FinishEncoding() throws IOException {
		// TODO Auto-generated method stub

	}

	/**
	 * Appends the encoded delta window to the output
	 * string.  The output string is not null-terminated and may contain embedded
	 * '\0' characters.
	 */
	public void Output() throws IOException {
		// TODO Auto-generated method stub

	}

	/**
	 *  Encode a RUN opcode for "size" copies of the value "byte".
	 */
	public void Run(int size, byte b) {
		EncodeInstruction(VCDiffCodeTableData.VCD_RUN, size);
		data_for_add_and_run_.put(b);
		target_length_ += size;
	}

	/**
	 * Write the header (as defined in section 4.1 of the RFC) to *out.
	 * This includes information that can be gathered
	 * before the first chunk of input is available.
	 */
	public void WriteHeader(EnumSet<VCDiffFormatExtensionFlags> formatExtensions) {
		// TODO Auto-generated method stub

	}

	public int target_length() {
		return target_length_;
	}

	/**
	 * If interleaved is true, sets data_for_add_and_run_ and
	 * addresses_for_copy_ to point at instructions_and_sizes_,
	 * so that instructions, sizes, addresses and data will be
	 * combined into a single interleaved stream.
	 * If interleaved is false, sets data_for_add_and_run_ and
	 * addresses_for_copy_ to point at their corresponding
	 * separate_... strings, so that the three sections will
	 * be generated separately from one another.
	 */
	void InitSectionPointers(boolean interleaved) {
		if (interleaved) {
			data_for_add_and_run_ = instructions_and_sizes_;
			addresses_for_copy_ = instructions_and_sizes_;
		} else {
			data_for_add_and_run_ = separate_data_for_add_and_run_;
			addresses_for_copy_ = separate_addresses_for_copy_;
		}
	}

	// Determines the best opcode to encode an instruction, and appends
	// or substitutes that opcode and its size into the
	// instructions_and_sizes_ string.
	private void EncodeInstruction(byte inst, int size, byte mode) {
		// TODO
	}

	private void EncodeInstruction(byte inst, int size) {
		EncodeInstruction(inst, size, (byte)0);
	}

	/**
	 * Calculates the number of bytes needed to store the given size value as a
	 * variable-length integer (VarintBE).
	 */
	static int CalculateLengthOfSizeAsVarint(int size) {
		// TODO:
	}

	// Appends the size value to the string as a variable-length integer.
	private static void AppendSizeToString(int size, string* out) {

	}

	// Appends the size value to the output string as a variable-length integer.
	private static void AppendSizeToOutputString(int size, OutputStringInterface* out) {

	}

	// Calculates the "Length of the delta encoding" field for the delta window
	// header, based on the sizes of the sections and of the other header
	// elements.
	private int CalculateLengthOfTheDeltaEncoding() {
		// TODO:
	}
}
